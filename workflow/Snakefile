configfile : "../config/config.yaml"

rule all :
    input :
        #Once : 
        "../data/merged_reference_genome/merged_reference.fasta",

        # For each run of reads : 
        expand("../data/reads_quality_check/{run}/{run}_fastqc.html", run=config["long_reads"]),
        expand("../data/merged_reference_genome/coverage_information_{run}.tsv", run=config["long_reads"]),

        # For each assembler-run pair :
        expand("../data/assemblies/{assembler}_{read}/assembly.fasta", read=config["long_reads"], assembler = config["long_reads_assemblers"]),
        expand("../data/assemblies_quality_check/{assembler}_{read}/summary/TSV", read=config["long_reads"], assembler = config["long_reads_assemblers"]),
        expand("../data/stats_reports/{assembler}_{read}/{assembler}_{read}_references_based_report.txt", read=config["long_reads"], assembler = config["long_reads_assemblers"]),
        expand("../data/stats_reports/{assembler}_{read}/{assembler}_{read}_references_free_report.txt", read=config["long_reads"], assembler = config["long_reads_assemblers"]),
             


def get_files_in_folder(path):
    files = os.listdir(path)
    for i in range(len(files)) :
        files[i] = path + files[i]
    arguments = " ".join(files)
    return arguments

rule reads_quality_check :
    input :
        script = "scripts/reads_quality_checker.sh", # script
        run = "../data/input_reads/{run}.fastq.gz", # data
    output :
        "../data/reads_quality_check/{run}/{run}_fastqc.html",
        "../data/reads_quality_check/{run}/{run}_fastqc.zip"
    message :
        "This rule checks the quality of every read and produces a human readable report"
    shell : 
        "{input.script} {input.run} ../data/reads_quality_check/{wildcards.run}"

path_to_reference_genomes = "../data/input_reference_genomes/" # /!\ The "/" at the end is important
reference_genomes = get_files_in_folder(path_to_reference_genomes)
rule references_merger :
    input :
        path_to_reference_genomes, # data
        script = "scripts/references_merger.sh", # script
    output : 
        "../data/merged_reference_genome/merged_reference.fasta"
    shell :
        "{input.script} {output} {reference_genomes}"

rule coverage_calculator :
    input :
        "scripts/sequencer_fetcher.sh", # script
        script = "scripts/coverage_calculator.sh", # script
        reference = "../data/merged_reference_genome/merged_reference.fasta", #data
        run = "../data/input_reads/{run}.fastq.gz", # data
    output :
        "../data/merged_reference_genome/coverage_information_{run}.tsv"
    resources :
        mem_mb_per_cpu=10000
    shell :
        "{input.script} {wildcards.run} {input.run} {input.reference} ../data/tmp/ {output}"

rule metaflye_assembly :
    input :
        "scripts/sequencer_fetcher.sh", # script
        script = "scripts/metaflye_assembler.sh", # script
        run = "../data/input_reads/{run}.fastq.gz", # data
    output :
        "../data/assemblies/metaflye_{run}/assembly.fasta",
    resources :
        cpus_per_task=4,
        mem_mb_per_cpu=25000
    shell :
        "./{input.script} {wildcards.run} {input.run} ../data/assemblies/metaflye_{wildcards.run}/" 

average_genome_size = 500000
rule canu_assembly :
    input :
        "scripts/sequencer_fetcher.sh", # script
        script = "scripts/canu_assembler.sh", # script
        run = "../data/input_reads/{run}.fastq.gz", # data
    output :
        "../data/assemblies/canu_{run}/assembly.fasta",
    resources :
        cpus_per_task=4,
        mem_mb_per_cpu=25000
    shell :
        "./{input.script} {wildcards.run} {input.run} ../data/assemblies/canu_{wildcards.run}/ 50000" 

rule miniasm_assembly :
    input :
        "scripts/sequencer_fetcher.sh", # script
        script = "scripts/miniasm_assembler.sh", # script
        run = "../data/input_reads/{run}.fastq.gz", # data
    output :
        "../data/assemblies/miniasm_{run}/assembly.fasta",
    resources :
        cpus_per_task=4,
        mem_mb_per_cpu=25000
    shell :
        "./{input.script} {wildcards.run} {input.run} ../data/assemblies/miniasm_{wildcards.run}/" 

rule flye_polishing : 
    input :
        script = "scripts/flye_polisher.sh", #script
        assembly = "../data/assemblies/{assembler_to_polish}_{run}/assembly.fasta", #data
        run = "../data/input_reads/{run}.fastq.gz", # data
    output : 
        "../data/assemblies/flye_polish_{assembler_to_polish}_{run}/assembly.fasta"
    shell : 
        "./{input.script} {wildcards.run} {input.run} {input.assembly} ../data/assemblies/flye_polish_{wildcards.assembler_to_polish}_{wildcards.run}/"

path_to_reference_genomes = "../data/input_reference_genomes/" # /!\ The "/" at the end is important
reference_genomes = get_files_in_folder(path_to_reference_genomes)
rule assembly_quality_check :
    input : 
        script = "scripts/assembly_quality_checker.sh", #script
        assembly = "../data/assemblies/{assembly}/assembly.fasta", #data
    resources :
        mem_mb_per_cpu=10000
    output :
        directory("../data/assemblies_quality_check/{assembly}/summary/TSV/")
    shell : 
        "{input.script} {input.assembly} ../data/assemblies_quality_check/{wildcards.assembly}/ {reference_genomes}"

rule assembly_references_based_stats :
    input : 
        quality_check = "../data/assemblies_quality_check/{assembly}_{run}/summary/TSV", 
        coverage_information = "../data/merged_reference_genome/coverage_information_{run}.tsv",
        script = "scripts/references_based_stats.py"
    output : 
        "../data/stats_reports/{assembly}_{run}/{assembly}_{run}_references_based_report.txt"
    shell : 
        "python3 {input.script} {input.quality_check}/ {input.coverage_information}  > {output}" 

rule compile_cpp : 
    input : 
        "{file}.cpp"
    output : 
        "{file}.out"
    shell : 
        "g++ {input} -std=c++11 -o {output}"

rule assembly_references_free_stats :
    input : 
        assembly = "../data/assemblies/{assembly}_{run}/assembly.fasta",
        run = "../data/input_reads/{run}.fastq",
        script = "scripts/references_free_stats.sh",
        auxiliary_script = "scripts/references_free_stats.out"
    output : 
        "../data/stats_reports/{assembly}_{run}/{assembly}_{run}_references_free_report.txt"
    shell : 
        "{input.script} {input.assembly} {input.run} {wildcards.assembly}_{wildcards.run} {wildcards.run} 5000 {output}" 



    

